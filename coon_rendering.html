<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Vincent Berthoux" />
  <title>Mesh Gradient rendering in Haskell</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="coon_rendering.css" type="text/css" />
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body>
<div id="header">
<h1 class="title">Mesh Gradient rendering in Haskell</h1>
<h2 class="author">Vincent Berthoux</h2>
<h3 class="date">October 2016</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#mesh-gradient-rendering-in-haskell">Mesh Gradient rendering in Haskell</a><ul>
<li><a href="#what-is-a-gradient-mesh">What is a gradient mesh</a></li>
<li><a href="#coon-patch">Coon patch</a><ul>
<li><a href="#coon-surface">Coon surface</a></li>
<li><a href="#dividing-a-cubic-bézier-curve">Dividing a cubic bézier curve</a></li>
<li><a href="#coon-patch-subdivision">Coon patch subdivision</a></li>
<li><a href="#color-weight-subdivision">Color weight subdivision</a></li>
<li><a href="#rendering">Rendering</a></li>
</ul></li>
<li><a href="#tensor-patch">Tensor Patch</a><ul>
<li><a href="#tensor-patch-subdivision">Tensor patch subdivision</a></li>
<li><a href="#subdivision">Subdivision</a></li>
</ul></li>
<li><a href="#coon-patch-to-tensor-patch">Coon patch to tensor patch</a></li>
<li><a href="#bicubic-interpolation">Bicubic interpolation</a></li>
<li><a href="#gradient-mesh-to-image-mesh">Gradient mesh to image mesh</a><ul>
<li><a href="#another-parametrization">Another parametrization</a></li>
</ul></li>
<li><a href="#making-it-faster">Making it faster</a><ul>
<li><a href="#forward-differentiation">Forward differentiation</a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#bugs">Bugs</a></li>
<li><a href="#reference">Reference</a></li>
</ul></li>
</ul>
</div>
<h1 id="mesh-gradient-rendering-in-haskell">Mesh Gradient rendering in Haskell</h1>
<p>The <a href="https://svgwg.org/svg2-draft/pservers.html#MeshGradientElement">SVG 2.0 Draft</a> include a new graphical element/texture: the Gradient Mesh. While not a novel technique, <a href="https://partners.adobe.com/public/developer/en/ps/sdk/TN5600.SmoothShading.pdf">postscript</a> use them as ShadingType 6 and 7 (Coons patch meshes and Tensor product patch meshes) as well as PDF <a href="http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/pdf_reference_1-7.pdf">PDF</a> (section 4.6.3), it's implementation details and understanding are worthwhile.</p>
<p>This document will describe how is defined a Gradient mesh within the SVG 2 draft specification, describes how to render it, look at the Postscript/PDF extension for tensor product and, finally the other possible extension for the tool.</p>
<p>Keep your <a href="http://pomax.github.io/bezierinfo/">pomax guide to the bezier curve</a> nearby and Let's roll.</p>
<h2 id="what-is-a-gradient-mesh">What is a gradient mesh</h2>
<p>If you didn't click the links in the introduction, you might still be wondering what is the gradient mesh, to explain it, let's take an axis aligned grid, composed of vertices and edges:</p>
<div class="figure">
<img src="coon_img/grid.png" title="Grid" />

</div>
<p>Now let's loosen the definition by swapping axis aligned line with (cubic) bezier curves. We also choose to be free in the position of the vertices:</p>
<div class="figure">
<img src="coon_img/grid_bez.png" title="Grid with bezier edges" />

</div>
<p>While funky lines are relatively interesting in their own rights, they are not that interesting for a shading, so we associate a color to the vertices of the grid:</p>
<div class="figure">
<img src="coon_img/grid_bez_color.png" title="Grid with colors" />

</div>
<p>For every cell of the array, we want to fill it by interpolating the colors of the vertices, by following the curves, possibly producing curved gradients along the way:</p>
<div class="figure">
<img src="coon_img/gradient_mesh_first.png" title="Final rendered mesh patch" />

</div>
<p>So here we are with our first gradient mesh. Defined by 5 by 4 vertices and their associated colors and the bezier control points for the edges. A cell of this array define a Coon patch, so 4 vertices and 4 edges and 4 colors. Knowing how to render one coon patch gives the key to render the whole mesh, you just render each cell individually.</p>
<h2 id="coon-patch">Coon patch</h2>
<p>We are now focusing on a single coon patch:</p>
<p>The black circle are the vertice from the mesh patch, and the dark blue one not in the corner are the control points for the cubic bezier curves, The control mesh is drawn in dark blue.</p>
<div class="figure">
<img src="coon_img/single_patch.png" title="A simple coon patch" />

</div>
<p>We can see that the color are the strongest in the corners, which correspond to the vertice of the mesh.</p>
<p>The main idea is then to subdivide this patch up to a point where either it is too small for further subdivision (if we are below the size of pixel for instance) or if further subdivision won't refine color, if color are too close we are not really interested.</p>
<div class="figure">
<img src="coon_img/single_patch_subdiv.png" title="A subdivided coon patch" />

</div>
<p>Managing to subdivide a coon patch in quadrant, means we can render our coon patch. To represent coon patch in Haskell, we'll use the following data types:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">--</span>
<span class="co">-- @</span>
<span class="co">--                        -----&gt;</span>
<span class="co">--                  North     _____----------------+</span>
<span class="co">--   ^          +------------/                     /</span>
<span class="co">--   |         /                                  /       |</span>
<span class="co">--   |        /                                  /        |</span>
<span class="co">--   |       /                                  /  east   |</span>
<span class="co">--   | west |                                  /          |</span>
<span class="co">--          |                                 |           v</span>
<span class="co">--           \                                 \   .</span>
<span class="co">--            \                  __-------------+</span>
<span class="co">--             +----------------/</span>
<span class="co">--                    South</span>
<span class="co">--                       &lt;-----</span>
<span class="co">-- @</span>
<span class="fu">--</span>
<span class="kw">data</span> <span class="dt">CoonPatch</span> colors <span class="fu">=</span> <span class="dt">CoonPatch</span>
    { _<span class="ot">north ::</span> <span class="fu">!</span><span class="dt">CubicBezier</span>
    , _<span class="ot">east ::</span> <span class="fu">!</span><span class="dt">CubicBezier</span>
    , _<span class="ot">south ::</span> <span class="fu">!</span><span class="dt">CubicBezier</span>
    , _<span class="ot">west ::</span> <span class="fu">!</span><span class="dt">CubicBezier</span>
    , _<span class="ot">coonValues ::</span> <span class="fu">!</span>colors
    }
    <span class="kw">deriving</span> <span class="dt">Show</span></code></pre></div>
<p><code>CoonPatch</code> represent the geomentry along with the colors stored in <code>_coonValues</code>. We can argue that this storage is redundant because the first and last point of each cubic bezier are shared, but manipulating a CubicBezier data types make things easier down the line. To store the colors we use another data type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Values associated to the corner of a patch</span>
<span class="co">-- @</span>
<span class="co">--  North           East</span>
<span class="co">--      +----------+</span>
<span class="co">--      |0        1|</span>
<span class="co">--      |          |</span>
<span class="co">--      |          |</span>
<span class="co">--      |3        2|</span>
<span class="co">--      +----------+</span>
<span class="co">--  West            South</span>
<span class="co">-- @</span>
<span class="kw">data</span> <span class="dt">ParametricValues</span> a <span class="fu">=</span> <span class="dt">ParametricValues</span>
  { _<span class="ot">northValue ::</span> <span class="fu">!</span>a
  , _<span class="ot">eastValue  ::</span> <span class="fu">!</span>a
  , _<span class="ot">southValue ::</span> <span class="fu">!</span>a
  , _<span class="ot">westValue  ::</span> <span class="fu">!</span>a
  }
  <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Show</span>)</code></pre></div>
<p>A fully instantiated type for a coon patch may then be <code>CoonPatch (ParametricValues PixelRGBA8)</code> (Using the pixel type from JuicyPixels)</p>
<p>A <code>CubicBezier</code> in encoded the following way:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Point</span> <span class="fu">=</span> <span class="dt">V2</span> <span class="dt">Float</span>

<span class="co">-- | Describe a cubic bezier spline, described</span>
<span class="co">-- using 4 points.</span>
<span class="fu">--</span>
<span class="co">-- &gt; stroke 4 JoinRound (CapRound, CapRound) $</span>
<span class="co">-- &gt;    CubicBezier (V2 0 10) (V2 205 250) (V2 (-10) 250) (V2 160 35)</span>
<span class="fu">--</span>
<span class="co">-- &lt;&lt;docimages/cubic_bezier.png&gt;&gt;</span>
<span class="fu">--</span>
<span class="kw">data</span> <span class="dt">CubicBezier</span> <span class="fu">=</span> <span class="dt">CubicBezier</span>
  { <span class="co">-- | Origin point, the spline will pass through it.</span>
    _<span class="ot">cBezierX0 ::</span> <span class="fu">!</span><span class="dt">Point</span>
    <span class="co">-- | First control point of the cubic bezier curve.</span>
  , _<span class="ot">cBezierX1 ::</span> <span class="fu">!</span><span class="dt">Point</span>
    <span class="co">-- | Second control point of the cubic bezier curve.</span>
  , _<span class="ot">cBezierX2 ::</span> <span class="fu">!</span><span class="dt">Point</span>
    <span class="co">-- | End point of the cubic bezier curve</span>
  , _<span class="ot">cBezierX3 ::</span> <span class="fu">!</span><span class="dt">Point</span>
  }
  <span class="kw">deriving</span> <span class="dt">Eq</span></code></pre></div>
<p><code>V2</code> being the Linear type for two component vector.</p>
<h3 id="coon-surface">Coon surface</h3>
<p>We can now look to the mathematical definition of the coon surface, which is defined by a simple equation:</p>
<p><span class="math display">\[ S = S_C + S_D - S_B \]</span></p>
<p>with each subsurface like:</p>
<pre><code>                    C                            C (1)
        C (0)        1    _____----------------+  1
         1  +------------/                     /
           /                                  /        
          /                                  /         
         /                                  /  D       
   D    |                                  /    2      
    1   |                                 |            
         \                                 \        
          \                  __-------------+
           +----------------/                C (1)
      C (0)             C                     2
       2                 2</code></pre>
<p><span class="math display">\[
S_C(u, v) = (1 - v) × C_1(u) + v × C_2(u), \\
S_D(u, v) = (1 - u) × D_1(v) + u × D_2(v), \\
S_B(u, v) = (1 - v) × [(1 - u) × C_1(0) + u × C_1(1) ] + v * [(1 - u) × C_2(0) + u × C_2(1)]
\]</span></p>
<p>We can see that <span class="math inline">\(S_C\)</span> is a linear interpolation between the top and bottom bezier curve, <span class="math inline">\(S_D\)</span> a linear interpolation between the left and right curve.</p>
<p>Finally, <span class="math inline">\(S_B\)</span> is a bilinear interpolation between the four corner of the coon patch. So by introducting a lerp function, we can rewrite the surfaces:</p>
<p><span class="math display">\[
S_C(u, v) = lerp(v, C_1(u), C_2(u)), \\
S_D(u, v) = lerp(u, D_1(v), D_2(v)), \\
S_B(u, v) = lerp(v, lerp(u, C_1(0), C_1(1)), lerp(u, C_2(0), C_2(1)))
\]</span></p>
<p>The <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> parameters are moving freely from 0 to 1 and are the UV coordinate inside the patch.</p>
<p>With this definition at end, we can write a function to get back a single point out of the surface:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Return a postion of a point in the coon patch.</span>
<span class="ot">coonPointAt ::</span> <span class="dt">CoonPatch</span> a <span class="ot">-&gt;</span> <span class="dt">UV</span> <span class="ot">-&gt;</span> <span class="dt">Point</span>
coonPointAt <span class="dt">CoonPatch</span> { <span class="fu">..</span> } (<span class="dt">V2</span> u v) <span class="fu">=</span> sc <span class="fu">^+^</span> sd <span class="fu">^-^</span> sb
  <span class="kw">where</span>
    <span class="dt">CubicBezier</span> c10 _ _ c11 <span class="fu">=</span> _north
    <span class="dt">CubicBezier</span> c21 _ _ c20 <span class="fu">=</span> _south

    sc <span class="fu">=</span> lerp v c2 c1
    sd <span class="fu">=</span> lerp u d2 d1
    sb <span class="fu">=</span> lerp v (lerp u c21 c20)
                (lerp u c11 c10)

    <span class="dt">CubicBezier</span> _ _ _ c1 <span class="fu">=</span> fst <span class="fu">$</span> cubicBezierBreakAt _north u
    <span class="dt">CubicBezier</span> _ _ _ c2 <span class="fu">=</span> fst <span class="fu">$</span> cubicBezierBreakAt _south (<span class="dv">1</span> <span class="fu">-</span> u)

    <span class="dt">CubicBezier</span> _ _ _ d2 <span class="fu">=</span> fst <span class="fu">$</span> cubicBezierBreakAt _east v
    <span class="dt">CubicBezier</span> _ _ _ d1 <span class="fu">=</span> fst <span class="fu">$</span> cubicBezierBreakAt _west (<span class="dv">1</span> <span class="fu">-</span> v)</code></pre></div>
<p>It uses the Linear library, with the <code>^+^</code> adding two vectors by performing pairwize addition, <code>^-^</code> doing pairwise subtraction. For the renderer, we want to divide the coon patch up to the pixel level, so we will use another algorithm than sampling this function.</p>
<p>A little note on the <a href="http://hackage.haskell.org/package/linear-1.20.5/docs/src/Linear-Vector.html#line-152"><code>lerp</code></a> doing a linear interpolation between two vectors, it's current behaviour is the following one</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">lerp <span class="dv">0</span> a b <span class="fu">=</span> b
lerp <span class="dv">1</span> a b <span class="fu">=</span> a</code></pre></div>
<p>So the use of lerp may appear &quot;reversed&quot; compared to others lerp definitions (and from the one in our formulas)</p>
<h3 id="dividing-a-cubic-bézier-curve">Dividing a cubic bézier curve</h3>
<p>We can use De Casteljau's algorithm to split a cubic bezier curve in two, as our degree is known, we can directly unroll the implementation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">midPoint ::</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Point</span>
midPoint a b <span class="fu">=</span> (a <span class="fu">^+^</span> b) <span class="fu">^*</span> <span class="fl">0.5</span>

<span class="ot">divideCubicBezier ::</span> <span class="dt">CubicBezier</span> <span class="ot">-&gt;</span> (<span class="dt">CubicBezier</span>, <span class="dt">CubicBezier</span>)
divideCubicBezier bezier<span class="fu">@</span>(<span class="dt">CubicBezier</span> a _ _ d) <span class="fu">=</span> (left, right) <span class="kw">where</span>
  left <span class="fu">=</span> <span class="dt">CubicBezier</span> a ab abbc abbcbccd
  right <span class="fu">=</span> <span class="dt">CubicBezier</span> abbcbccd bccd cd d
  (ab, _bc, cd, abbc, bccd, abbcbccd) <span class="fu">=</span> splitCubicBezier bezier

<span class="ot">splitCubicBezier ::</span> <span class="dt">CubicBezier</span> <span class="ot">-&gt;</span> (<span class="dt">Point</span>, <span class="dt">Point</span>, <span class="dt">Point</span>, <span class="dt">Point</span>, <span class="dt">Point</span>, <span class="dt">Point</span>)
splitCubicBezier (<span class="dt">CubicBezier</span> a b c d) <span class="fu">=</span> (ab, bc, cd, abbc, bccd, abbcbccd)
  <span class="kw">where</span>
    <span class="co">--                     BC</span>
    <span class="co">--         B X----------X---------X C</span>
    <span class="co">--    ^     /      ___/   \___     \     ^</span>
    <span class="co">--   u \   /   __X------X------X_   \   / v</span>
    <span class="co">--      \ /___/ ABBC       BCCD  \___\ /</span>
    <span class="co">--    AB X/                          \X CD</span>
    <span class="co">--      /                              \</span>
    <span class="co">--     /                                \</span>
    <span class="co">--    /                                  \</span>
    <span class="co">-- A X                                    X D</span>
    ab <span class="fu">=</span> a <span class="ot">`midPoint`</span> b
    bc <span class="fu">=</span> b <span class="ot">`midPoint`</span> c
    cd <span class="fu">=</span> c <span class="ot">`midPoint`</span> d

    abbc <span class="fu">=</span> ab <span class="ot">`midPoint`</span> bc
    bccd <span class="fu">=</span> bc <span class="ot">`midPoint`</span> cd
    abbcbccd <span class="fu">=</span> abbc <span class="ot">`midPoint`</span> bccd</code></pre></div>
<p>We introduce a new Linear operator <code>^*</code> which multiplies all the component of the vector (on the left) by the scalar on the right. We can also easily represent a straight line using a cubic bezier curve:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">straightLine ::</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">CubicBezier</span>
straightLine a b <span class="fu">=</span> <span class="dt">CubicBezier</span> a p1 p2 b <span class="kw">where</span>
  p1 <span class="fu">=</span> lerp (<span class="dv">1</span><span class="fu">/</span><span class="dv">3</span>) b a
  p2 <span class="fu">=</span> lerp (<span class="dv">2</span><span class="fu">/</span><span class="dv">3</span>) b a</code></pre></div>
<p>We can also flip the direction of a cubic bezier curve, without altearing it's appearance</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">inverseBezier ::</span> <span class="dt">CubicBezier</span> <span class="ot">-&gt;</span> <span class="dt">CubicBezier</span>
inverseBezier (<span class="dt">CubicBezier</span> a b c d) <span class="fu">=</span> <span class="dt">CubicBezier</span> d c b a</code></pre></div>
<h3 id="coon-patch-subdivision">Coon patch subdivision</h3>
<p>To split a coon patch in two, we have to know how to produce a new cubic bezier between the two new patch. Splitting a cubic bezier for the edges will use the function defined above. We will use the algorithm described in the paper &quot;An efficient algorithm for subdividing linear Coons surfaces&quot;[1].</p>
<p>The main hindsight gained from the paper is how to calculate the contribution of <span class="math inline">\(S_D\)</span> when spliting <span class="math inline">\(S_C\)</span> in two. The linear part (<span class="math inline">\(S_B\)</span>) is still a bilinear interpolation, the <span class="math inline">\(S_C\)</span> part is a direct interpolation of <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span>.</p>
<p>The contribution of <span class="math inline">\(S_D\)</span> when splitting <span class="math inline">\(S_C\)</span> is in fact a straight line with endpoints the middle of <span class="math inline">\(D_1\)</span> and <span class="math inline">\(D_2\)</span>. With these contribution, the regular equation for <span class="math inline">\(S\)</span> can be applied. It can be noted that the paper use a notation involving cardinal points which have been used when defining the various data types.</p>
<p>The combination is then stated by the definition below:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Calculate the new cubic bezier using equation for S</span>
<span class="ot">combine ::</span> <span class="dt">CubicBezier</span> <span class="ot">-&gt;</span> <span class="dt">CubicBezier</span> <span class="ot">-&gt;</span> <span class="dt">CubicBezier</span> <span class="ot">-&gt;</span> <span class="dt">CubicBezier</span>
combine (<span class="dt">CubicBezier</span> a1 b1 c1 d1)
        (<span class="dt">CubicBezier</span> a2 b2 c2 d2)
        (<span class="dt">CubicBezier</span> a3 b3 c3 d3) <span class="fu">=</span>
  <span class="dt">CubicBezier</span> (a1 <span class="fu">^+^</span> a2 <span class="fu">^-^</span> a3)
              (b1 <span class="fu">^+^</span> b2 <span class="fu">^-^</span> b3)
              (c1 <span class="fu">^+^</span> c2 <span class="fu">^-^</span> c3)
              (d1 <span class="fu">^+^</span> d2 <span class="fu">^-^</span> d3)</code></pre></div>
<p>And the proper subdivision for the coon patch is then:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Split a coon patch in two vertically</span>
<span class="fu">--</span>
<span class="co">-- @</span>
<span class="co">--                        ---------&gt;</span>
<span class="co">--                  North     +____----------------+</span>
<span class="co">--   ^          +------------/:                    /</span>
<span class="co">--   |         /              :                   /       |</span>
<span class="co">--   |        /               :                  /        |</span>
<span class="co">--   |       /               :                  /  east   |</span>
<span class="co">--   | west |               :                  /          |</span>
<span class="co">--          |               :                 |           v</span>
<span class="co">--           \               :                 \    .   </span>
<span class="co">--            \               :  __-------------+</span>
<span class="co">--             +--------------+-/</span>
<span class="co">--                    South</span>
<span class="co">--                       &lt;---------</span>
<span class="co">-- @</span>
<span class="fu">--</span>
<span class="ot">subdividePatch ::</span> <span class="dt">CoonPatch</span> (<span class="dt">V2</span> <span class="dt">CoonColorWeight</span>)
               <span class="ot">-&gt;</span> <span class="dt">Subdivided</span> (<span class="dt">CoonPatch</span> (<span class="dt">V2</span> <span class="dt">CoonColorWeight</span>))
subdividePatch patch <span class="fu">=</span> <span class="dt">Subdivided</span>
    { _northWest <span class="fu">=</span> northWest
    , _northEast <span class="fu">=</span> northEast
    , _southWest <span class="fu">=</span> southWest
    , _southEast <span class="fu">=</span> southEast
    } <span class="kw">where</span>
  north<span class="fu">@</span>(<span class="dt">CubicBezier</span> nw _ _ ne) <span class="fu">=</span> _north patch
  south<span class="fu">@</span>(<span class="dt">CubicBezier</span> se _ _ sw) <span class="fu">=</span> _south patch

  <span class="co">-- Midpoints used for S_B</span>
  midNorthLinear <span class="fu">=</span> nw <span class="ot">`midPoint`</span> ne
  midSouthLinear <span class="fu">=</span> sw <span class="ot">`midPoint`</span> se
  midWestLinear <span class="fu">=</span> nw <span class="ot">`midPoint`</span> sw
  midEastLinear <span class="fu">=</span> ne <span class="ot">`midPoint`</span> se

  <span class="co">-- These points are to calculate S_C and S_D</span>
  (northLeft<span class="fu">@</span>(<span class="dt">CubicBezier</span> _ _ _ midNorth), northRight) <span class="fu">=</span> divideCubicBezier north
  (southRight, southLeft<span class="fu">@</span>(<span class="dt">CubicBezier</span> midSouth _ _ _ )) <span class="fu">=</span> divideCubicBezier south
  (westBottom, westTop<span class="fu">@</span>(<span class="dt">CubicBezier</span> midWest _ _ _)) <span class="fu">=</span> divideCubicBezier <span class="fu">$</span> _west patch
  (eastTop<span class="fu">@</span>(<span class="dt">CubicBezier</span> _ _ _ midEast), eastBottom) <span class="fu">=</span> divideCubicBezier <span class="fu">$</span> _east patch

  <span class="co">-- This points are to calculate S_B</span>
  midNorthSouth <span class="fu">=</span> north <span class="ot">`midCurve`</span> south
  midEastWest <span class="fu">=</span> _east patch <span class="ot">`midCurve`</span> _west patch 

  <span class="co">-- Here we calculate S_D sub curves</span>
  (splitNorthSouthTop, splitNorthSouthBottom) <span class="fu">=</span>
      divideCubicBezier <span class="fu">$</span> combine
        midEastWest                                     <span class="co">-- S_D</span>
        (midNorth <span class="ot">`straightLine`</span> midSouth)              <span class="co">-- S_C contribution</span>
        (midNorthLinear <span class="ot">`straightLine`</span> midSouthLinear)  <span class="co">-- S_B contribution</span>

  (splitWestEastLeft, splitWestEastRight) <span class="fu">=</span>
      divideCubicBezier <span class="fu">$</span> combine
        midNorthSouth                                   <span class="co">-- S_C</span>
        (midWest <span class="ot">`straightLine`</span> midEast)                <span class="co">-- S_D contribution</span>
        (midWestLinear <span class="ot">`straightLine`</span> midEastLinear)    <span class="co">-- S_B contribution</span>

  weights <span class="fu">=</span> subdivideWeights <span class="fu">$</span> _coonValues patch

  <span class="co">-- reconstruction of the new sub-patches.</span>
  northWest <span class="fu">=</span> <span class="dt">CoonPatch</span>
    { _west <span class="fu">=</span> westTop
    , _north <span class="fu">=</span> northLeft
    , _east <span class="fu">=</span> splitNorthSouthTop
    , _south <span class="fu">=</span> inverseBezier splitWestEastLeft
    , _coonValues <span class="fu">=</span> _northWest weights
    }

  northEast <span class="fu">=</span> <span class="dt">CoonPatch</span>
    { _west <span class="fu">=</span> inverseBezier splitNorthSouthTop
    , _north <span class="fu">=</span> northRight
    , _east <span class="fu">=</span> eastTop
    , _south <span class="fu">=</span> inverseBezier splitWestEastRight
    , _coonValues <span class="fu">=</span> _northEast weights
    }

  southWest <span class="fu">=</span> <span class="dt">CoonPatch</span>
    { _west <span class="fu">=</span> westBottom
    , _north <span class="fu">=</span> splitWestEastLeft
    , _east <span class="fu">=</span> splitNorthSouthBottom
    , _south <span class="fu">=</span> southLeft
    , _coonValues <span class="fu">=</span> _southWest weights
    }

  southEast <span class="fu">=</span> <span class="dt">CoonPatch</span>
    { _west <span class="fu">=</span> inverseBezier splitNorthSouthBottom
    , _north <span class="fu">=</span> splitWestEastRight
    , _east <span class="fu">=</span> eastBottom
    , _south <span class="fu">=</span> southRight
    , _coonValues <span class="fu">=</span> _southEast weights
    }</code></pre></div>
<h3 id="color-weight-subdivision">Color weight subdivision</h3>
<p>The coon function use a <code>subdivideWeights</code> function to subdivide the weight at the corner of the patch, this is a straightforward operation, the <code>ParametricValues</code> data type is a generic data type storing values for the four corner of the patch. We don't directly interpolate pixels, but instead the UV parametric coordinate within the patch. Subdividing it is just creating new squares with new coordinate using midPoints.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">subdivideWeights ::</span> <span class="dt">ParametricValues</span> (<span class="dt">V2</span> <span class="dt">CoonColorWeight</span>)
                 <span class="ot">-&gt;</span> <span class="dt">Subdivided</span> (<span class="dt">ParametricValues</span> (<span class="dt">V2</span> <span class="dt">CoonColorWeight</span>))
subdivideWeights values <span class="fu">=</span> <span class="dt">Subdivided</span> { <span class="fu">..</span> } <span class="kw">where</span>
  <span class="dt">ParametricValues</span>
    { _westValue <span class="fu">=</span> west
    , _northValue <span class="fu">=</span> north
    , _southValue <span class="fu">=</span> south
    , _eastValue <span class="fu">=</span> east
    } <span class="fu">=</span> values

  <span class="co">--  N       midNorth    E</span>
  <span class="co">--      +-------+------+</span>
  <span class="co">--      |0      :     1|</span>
  <span class="co">--   mid|   grid:Mid   |</span>
  <span class="co">--  West+=======:======+ midEast</span>
  <span class="co">--      |       :      |</span>
  <span class="co">--      |3      :     2|</span>
  <span class="co">--      +-------+------+</span>
  <span class="co">--  W       midSouth    S</span>
  midNorthValue <span class="fu">=</span> north <span class="ot">`midPoint`</span> east
  midWestValue <span class="fu">=</span> north <span class="ot">`midPoint`</span> west
  midSoutValue <span class="fu">=</span> west <span class="ot">`midPoint`</span> south
  midEastValue <span class="fu">=</span> east <span class="ot">`midPoint`</span> south

  gridMidValue <span class="fu">=</span> midSoutValue <span class="ot">`midPoint`</span> midNorthValue

  _northWest <span class="fu">=</span> <span class="dt">ParametricValues</span>
    { _northValue <span class="fu">=</span> north
    , _eastValue <span class="fu">=</span> midNorthValue
    , _southValue <span class="fu">=</span> gridMidValue
    , _westValue <span class="fu">=</span> midWestValue
    }

  _northEast <span class="fu">=</span> <span class="dt">ParametricValues</span>
    { _northValue <span class="fu">=</span> midNorthValue
    , _eastValue <span class="fu">=</span> east
    , _southValue <span class="fu">=</span> midEastValue
    , _westValue <span class="fu">=</span> gridMidValue
    }

  _southWest <span class="fu">=</span> <span class="dt">ParametricValues</span>
    { _northValue <span class="fu">=</span> midWestValue
    , _eastValue  <span class="fu">=</span> gridMidValue
    , _southValue <span class="fu">=</span> midSoutValue
    , _westValue <span class="fu">=</span> west
    }
  
  _southEast <span class="fu">=</span> <span class="dt">ParametricValues</span>
    { _northValue <span class="fu">=</span> gridMidValue
    , _eastValue <span class="fu">=</span> midEastValue
    , _southValue <span class="fu">=</span> south
    , _westValue <span class="fu">=</span> midSoutValue
    }</code></pre></div>
<p>It is assumed that the original weight are a unit square:</p>
<pre><code> 0,0                1,0
    +--------------+
    |              |
    |              |
    |              |
    |              |
    |              |
    +--------------+
 0,1               1,1</code></pre>
<h3 id="rendering">Rendering</h3>
<p>We just need a way to convert between UV coordinates to real color to fill our canvas, it is rather simple, if we store the initial pixel in ParametricValues, we just have to perform a bilinear interpolation to get the final color:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">meanValue ::</span> <span class="dt">ParametricValues</span> (<span class="dt">V2</span> <span class="dt">CoonColorWeight</span>) <span class="ot">-&gt;</span> <span class="dt">V2</span> <span class="dt">CoonColorWeight</span>
meanValue <span class="fu">=</span> (<span class="fu">^*</span> <span class="fl">0.25</span>) <span class="fu">.</span> getSum <span class="fu">.</span> foldMap <span class="dt">Sum</span>

<span class="co">-- | Interpolate a 2D point in a given type</span>
<span class="kw">class</span> <span class="dt">BiSampleable</span> sampled px <span class="fu">|</span> sampled <span class="ot">-&gt;</span> px <span class="kw">where</span>
  <span class="co">-- | The interpolation function</span>
<span class="ot">  interpolate ::</span> sampled <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> px

<span class="co">-- | Basic bilinear interpolator</span>
<span class="kw">instance</span> <span class="dt">BiSampleable</span> (<span class="dt">ParametricValues</span> <span class="dt">PixelRGBA8</span>) <span class="dt">PixelRGBA8</span> <span class="kw">where</span>
  <span class="ot">{-# INLINE interpolate #-}</span>
  interpolate <span class="fu">=</span> bilinearPixelInterpolation

<span class="ot">bilinearPixelInterpolation ::</span> <span class="dt">ParametricValues</span> <span class="dt">PixelRGBA8</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">PixelRGBA8</span>
bilinearPixelInterpolation (<span class="dt">ParametricValues</span> { <span class="fu">..</span> }) <span class="fu">!</span>dx <span class="fu">!</span>dy <span class="fu">=</span> 
  lerpColor dy (lerpColor dx _northValue _eastValue) (lerpColor dx _westValue _southValue)
  <span class="kw">where</span>
   lerpWord8 zeroToOne a b <span class="fu">=</span>
      floor <span class="fu">$</span> (<span class="dv">1</span> <span class="fu">-</span> zeroToOne) <span class="fu">*</span> fromIntegral a <span class="fu">+</span> zeroToOne fromIntegral b
   lerpColor zeroToOne (<span class="dt">PixelRGBA8</span> r g b a) (<span class="dt">PixelRGBA8</span> r&#39; g&#39; b&#39; a&#39;) <span class="fu">=</span>
      <span class="dt">PixelRGBA8</span>
        (lerpWord8 zeroToOne r r&#39;)
        (lerpWord8 zeroToOne g g&#39;)
        (lerpWord8 zeroToOne b b&#39;)
        (lerpWord8 zeroToOne a a&#39;)</code></pre></div>
<p>We now have everything that is needed to render the coon patch, using a dumb heuristic to enhance later we can write the rendering code, assuming that we already have a rasterizer (like Rasterific) that can fill a path with cubic bezier.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">renderCoonPatch ::</span> forall interp s<span class="fu">.</span>  (<span class="dt">BiSampleable</span> interp <span class="dt">PixelRGBA8</span>)
                <span class="ot">=&gt;</span> <span class="dt">CoonPatch</span> interp <span class="ot">-&gt;</span> <span class="dt">DrawContext</span> (<span class="dt">ST</span> s) <span class="dt">PixelRGBA8</span> ()
renderCoonPatch originalPatch <span class="fu">=</span> go maxDeepness basePatch <span class="kw">where</span>
  maxDeepness <span class="fu">=</span> maxColorDeepness baseColors
  baseColors <span class="fu">=</span> _coonValues originalPatch

  basePatch <span class="fu">=</span> originalPatch { _coonValues <span class="fu">=</span> parametricBase }

  <span class="co">-- Here we draw the patch as a regular &quot;PATH&quot; with any</span>
  <span class="co">-- rendering engine</span>
  drawPatchUniform <span class="dt">CoonPatch</span> { <span class="fu">..</span> } <span class="fu">=</span> fillWithTextureNoAA <span class="dt">FillWinding</span> texture geometry <span class="kw">where</span>
    geometry <span class="fu">=</span> toPrim <span class="fu">&lt;$&gt;</span> [_north, _east, _south, _west]
    <span class="fu">!</span>(<span class="dt">V2</span> u v) <span class="fu">=</span>meanValue _coonValues
    <span class="fu">!</span>texture <span class="fu">=</span> <span class="dt">SolidTexture</span> <span class="fu">$</span> interpolate baseColors u v

  go <span class="dv">0</span> patch <span class="fu">=</span> drawPatchUniform patch
  go depth (subdividePatch <span class="ot">-&gt;</span> <span class="dt">Subdivided</span> { <span class="fu">..</span> }) <span class="fu">=</span>
    <span class="kw">let</span> d <span class="fu">=</span> depth <span class="fu">-</span> (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>) <span class="kw">in</span>
    go d _northWest <span class="fu">&gt;&gt;</span> go d _northEast <span class="fu">&gt;&gt;</span> go d _southWest <span class="fu">&gt;&gt;</span> go d _southEast</code></pre></div>
<p>To have an idea of the process, here's a GIF of various subdivision levels. At some points there is too much different colors to have a correct encoding and the dithering scramble it a bit:</p>
<div class="figure">
<img src="coon_img/subdiv.gif" />

</div>
<h2 id="tensor-patch">Tensor Patch</h2>
<p>What if we want to control more precisely how the color spread within a patch?</p>
<p>With a coon patch this is rather limited, but we have another tool to do this, the tensor patch. Here is both side by side, the coon patch on the left, the tensor patch on the right:</p>
<p><img src="coon_img/compare_coon.png" title="Coon patch" alt="Coon patch" /> <img src="coon_img/compare_tensor.png" title="Tensor patch" alt="Tensor patch" /></p>
<p>There is a difference of construction between the two, the Tensor patch is made of a matrix of 4x4 points with points in the middle of the matrix helping to &quot;drag&quot; the color one way or another:</p>
<div class="figure">
<img src="coon_img/compare_tensor_debug.png" title="Tensor patch with control mesh" alt="Tensor patch debug" />
<p class="caption">Tensor patch debug</p>
</div>
<p>In the patch below, each circle represent a control point of the tensor patch, the curves defined by these points are ommited for clarity.</p>
<h3 id="tensor-patch-subdivision">Tensor patch subdivision</h3>
<p>So a nice little tensor patch:</p>
<div class="figure">
<img src="coon_img/split_tensor_orig.png" title="Simple tensor" />

</div>
<p>Which has the control mesh: (this time with curve outline drawn):</p>
<div class="figure">
<img src="coon_img/split_tensor_orig_debug.png" title="Tensor with control mesh and points" />

</div>
<p>So the basic subdivision technique is to split each of the 4 cubic bezier curve in each direction:</p>
<div class="figure">
<img src="coon_img/split_tensor_orig_subH.png" title="Tensor horizontally subdivided" />

</div>
<p>We can then interpret the matrix in the other direction (vertically), and subdivide again the tensor patch. Here we subdivide vertically just the right patch:</p>
<div class="figure">
<img src="coon_img/split_tensor_orig_subHVR.png" title="And with vertical subdivision" />

</div>
<h3 id="subdivision">Subdivision</h3>
<p>We can simply switch orientation of a tensor patch by transposing its coefficients:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">TensorPatch</span> px <span class="fu">=</span> <span class="dt">TensorPatch</span>
  { _<span class="ot">curve0 ::</span> <span class="fu">!</span><span class="dt">CubicBezier</span>
  , _<span class="ot">curve1 ::</span> <span class="fu">!</span><span class="dt">CubicBezier</span>
  , _<span class="ot">curve2 ::</span> <span class="fu">!</span><span class="dt">CubicBezier</span>
  , _<span class="ot">curve3 ::</span> <span class="fu">!</span><span class="dt">CubicBezier</span>
  , _<span class="ot">tensorValues ::</span> <span class="fu">!</span>(<span class="dt">ParametricValues</span> px)
  }

<span class="ot">transposeParametricValues ::</span> <span class="dt">ParametricValues</span> a <span class="ot">-&gt;</span> <span class="dt">ParametricValues</span> a
transposeParametricValues (<span class="dt">ParametricValues</span> n e s w) <span class="fu">=</span> <span class="dt">ParametricValues</span> n w s e

<span class="ot">transposePatch ::</span> <span class="dt">TensorPatch</span> px <span class="ot">-&gt;</span> <span class="dt">TensorPatch</span> px
transposePatch <span class="dt">TensorPatch</span>
  { _curve0 <span class="fu">=</span> <span class="dt">CubicBezier</span> c00 c01 c02 c03
  , _curve1 <span class="fu">=</span> <span class="dt">CubicBezier</span> c10 c11 c12 c13
  , _curve2 <span class="fu">=</span> <span class="dt">CubicBezier</span> c20 c21 c22 c23
  , _curve3 <span class="fu">=</span> <span class="dt">CubicBezier</span> c30 c31 c32 c33
  , _tensorValues <span class="fu">=</span> values
  } <span class="fu">=</span> <span class="dt">TensorPatch</span>
    { _curve0 <span class="fu">=</span> <span class="dt">CubicBezier</span> c00 c10 c20 c30
    , _curve1 <span class="fu">=</span> <span class="dt">CubicBezier</span> c01 c11 c21 c31
    , _curve2 <span class="fu">=</span> <span class="dt">CubicBezier</span> c02 c12 c22 c32
    , _curve3 <span class="fu">=</span> <span class="dt">CubicBezier</span> c03 c13 c23 c33
    , _tensorValues <span class="fu">=</span> transposeParametricValues values
    }</code></pre></div>
<p>We then just have to subdivide horizontally</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">horizontalTensorSubdivide ::</span> <span class="dt">TensorPatch</span> (<span class="dt">V2</span> <span class="dt">CoonColorWeight</span>)
                          <span class="ot">-&gt;</span> (<span class="dt">TensorPatch</span> (<span class="dt">V2</span> <span class="dt">CoonColorWeight</span>), <span class="dt">TensorPatch</span> (<span class="dt">V2</span> <span class="dt">CoonColorWeight</span>))
horizontalTensorSubdivide p <span class="fu">=</span> (<span class="dt">TensorPatch</span> l0 l1 l2 l3 vl, <span class="dt">TensorPatch</span> r0 r1 r2 r3 vr) <span class="kw">where</span>
  (l0, r0) <span class="fu">=</span> divideCubicBezier <span class="fu">$</span> _curve0 p
  (l1, r1) <span class="fu">=</span> divideCubicBezier <span class="fu">$</span> _curve1 p
  (l2, r2) <span class="fu">=</span> divideCubicBezier <span class="fu">$</span> _curve2 p
  (l3, r3) <span class="fu">=</span> divideCubicBezier <span class="fu">$</span> _curve3 p
  (vl, vr) <span class="fu">=</span> subdivideHorizontal <span class="fu">$</span> _tensorValues p</code></pre></div>
<p>And we can finally subdivide the patch in 4 subpatch:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">subdivideTensorPatch ::</span> <span class="dt">TensorPatch</span> (<span class="dt">V2</span> <span class="dt">CoonColorWeight</span>)
                     <span class="ot">-&gt;</span> <span class="dt">Subdivided</span> (<span class="dt">TensorPatch</span> (<span class="dt">V2</span> <span class="dt">CoonColorWeight</span>))
subdivideTensorPatch p <span class="fu">=</span> subdivided <span class="kw">where</span>
  (west, east) <span class="fu">=</span> horizontalTensorSubdivide p
  (northWest, southWest) <span class="fu">=</span> horizontalTensorSubdivide <span class="fu">$</span> transposePatch west
  (northEast, southEast) <span class="fu">=</span> horizontalTensorSubdivide <span class="fu">$</span> transposePatch east
  subdivided <span class="fu">=</span> <span class="dt">Subdivided</span>
    { _northWest <span class="fu">=</span> northWest
    , _northEast <span class="fu">=</span> northEast
    , _southWest <span class="fu">=</span> southWest
    , _southEast <span class="fu">=</span> southEast
    }</code></pre></div>
<p>The global rendering is similar to the one of the coon patch, so it won't be displayed here.</p>
<h2 id="coon-patch-to-tensor-patch">Coon patch to tensor patch</h2>
<p>A tensor patch have 4 additional compared to the coon patch. It is therefore more complex, and we could pass from the coon patch to the tensor one. If <span class="math inline">\(S(u,v)\)</span> is the point at the position u, v on the coon surface, the 4 additional points are expressed in the following way in the PDF reference 1.7, and in various articles:</p>
<p><span class="math display">\[
\begin{matrix}
p11 &amp; = &amp; S(1/3, 1/3) \\
p21 &amp; = &amp; S(2/3, 1/3) \\
p12 &amp; = &amp; S(1/3, 2/3) \\
p22 &amp; = &amp; S(2/3, 2/3)
\end{matrix}
\]</span></p>
<p>With this, converting the following gradient mesh (expressed using the SVG2.0 Draft syntax):</p>
<div class="sourceCode"><pre class="sourceCode xml"><code class="sourceCode xml"><span class="kw">&lt;?xml</span> version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;<span class="kw">?&gt;</span>
<span class="kw">&lt;svg</span><span class="ot"> xmlns=</span><span class="st">&quot;http://www.w3.org/2000/svg&quot;</span><span class="ot"> xmlns:xlink=</span><span class="st">&quot;http://www.w3.org/1999/xlink&quot;</span>
<span class="ot">   version=</span><span class="st">&quot;1.1&quot;</span><span class="ot"> width=</span><span class="st">&quot;400&quot;</span><span class="ot"> height=</span><span class="st">&quot;400&quot;</span><span class="kw">&gt;</span>
  <span class="kw">&lt;defs&gt;</span>
    <span class="kw">&lt;meshgradient</span><span class="ot"> x=</span><span class="st">&quot;54&quot;</span><span class="ot"> y=</span><span class="st">&quot;163&quot;</span><span class="ot"> id=</span><span class="st">&quot;meshgradient1&quot;</span><span class="ot"> gradientUnits=</span><span class="st">&quot;userSpaceOnUse&quot;</span><span class="kw">&gt;</span>
      <span class="kw">&lt;meshrow&gt;</span>
        <span class="kw">&lt;meshpatch&gt;</span>
          <span class="kw">&lt;stop</span><span class="ot"> path=</span><span class="st">&quot;C  68, 110, 110,  68, 163,  54&quot;</span><span class="ot">  stop-color=</span><span class="st">&quot;red&quot;</span>    <span class="kw">/&gt;</span>
          <span class="kw">&lt;stop</span><span class="ot"> path=</span><span class="st">&quot;C 153,  82, 148, 111, 143, 143&quot;</span><span class="ot">  stop-color=</span><span class="st">&quot;red&quot;</span>    <span class="kw">/&gt;</span>
          <span class="kw">&lt;stop</span><span class="ot"> path=</span><span class="st">&quot;L 143, 143&quot;</span><span class="ot">                      stop-color=</span><span class="st">&quot;white &quot;</span> <span class="kw">/&gt;</span>
          <span class="kw">&lt;stop</span><span class="ot"> path=</span><span class="st">&quot;C 113, 146,  82, 153&quot;</span><span class="ot">            stop-color=</span><span class="st">&quot;white&quot;</span>  <span class="kw">/&gt;</span>
        <span class="kw">&lt;/meshpatch&gt;</span>
        <span class="kw">&lt;meshpatch&gt;</span>
          <span class="kw">&lt;stop</span><span class="ot"> path=</span><span class="st">&quot;C 245,  35, 325,  83, 345, 163&quot;</span>                      <span class="kw">/&gt;</span>
          <span class="kw">&lt;stop</span><span class="ot"> path=</span><span class="st">&quot;C 281, 138, 209, 136, 143, 143&quot;</span><span class="ot">  stop-color=</span><span class="st">&quot;red&quot;</span>    <span class="kw">/&gt;</span>
          <span class="kw">&lt;stop</span><span class="ot"> path=</span><span class="st">&quot;L 143, 143&quot;</span><span class="ot">                      stop-color=</span><span class="st">&quot;white&quot;</span>  <span class="kw">/&gt;</span>
        <span class="kw">&lt;/meshpatch&gt;</span>
        <span class="kw">&lt;meshpatch&gt;</span>
          <span class="kw">&lt;stop</span><span class="ot"> path=</span><span class="st">&quot;C 374, 273, 273, 374, 163, 345&quot;</span>                      <span class="kw">/&gt;</span>
          <span class="kw">&lt;stop</span><span class="ot"> path=</span><span class="st">&quot;C 138, 281, 136, 209, 143, 143&quot;</span><span class="ot">  stop-color=</span><span class="st">&quot;red&quot;</span>    <span class="kw">/&gt;</span>
          <span class="kw">&lt;stop</span><span class="ot"> path=</span><span class="st">&quot;L 143, 143&quot;</span><span class="ot">                      stop-color=</span><span class="st">&quot;white &quot;</span> <span class="kw">/&gt;</span>
        <span class="kw">&lt;/meshpatch&gt;</span>
        <span class="kw">&lt;meshpatch&gt;</span>
          <span class="kw">&lt;stop</span><span class="ot"> path=</span><span class="st">&quot;C  83, 325,  35, 245,  54, 163&quot;</span>                      <span class="kw">/&gt;</span>
          <span class="kw">&lt;stop</span><span class="ot"> path=</span><span class="st">&quot;C  82, 153, 111, 148, 143, 143&quot;</span><span class="ot">  stop-color=</span><span class="st">&quot;red&quot;</span>    <span class="kw">/&gt;</span>
          <span class="kw">&lt;stop</span><span class="ot"> path=</span><span class="st">&quot;L 143, 143&quot;</span><span class="ot">                      stop-color=</span><span class="st">&quot;white &quot;</span> <span class="kw">/&gt;</span>
        <span class="kw">&lt;/meshpatch&gt;</span>
       <span class="kw">&lt;/meshrow&gt;</span>
     <span class="kw">&lt;/meshgradient&gt;</span>
  <span class="kw">&lt;/defs&gt;</span>
  <span class="kw">&lt;rect</span><span class="ot"> width=</span><span class="st">&quot;360&quot;</span><span class="ot"> height=</span><span class="st">&quot;360&quot;</span><span class="ot"> x=</span><span class="st">&quot;20&quot;</span><span class="ot"> y=</span><span class="st">&quot;20&quot;</span><span class="ot"> style=</span><span class="st">&quot;fill:url(#meshgradient1); stroke:red&quot;</span> <span class="kw">/&gt;</span>
<span class="kw">&lt;/svg&gt;</span></code></pre></div>
<p>and render it as a bunch of tensor patches:</p>
<div class="figure">
<img src="coon_img/bad_coon_to_tensor.png" />

</div>
<p>You can see the lines in the border of the patches, and the diamond shape of the white hallow?</p>
<p>Well it's total crap, even if intuitive and elegant, putting the control points at third of the bezier distance is just wrong, we can get a intuition into the problem by plotting the curve and control points of the previous rendering:</p>
<div class="figure">
<img src="coon_img/bad_coon_to_tensor_control.png" />

</div>
<p>We can see the near straight line formed with the additional control points, whereas the original render is much smoother and &quot;round&quot;. The answer is elsewhere, thanks to the one giving the pointer in the Cairo source code, indicating the <a href="http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/PDF32000_2008.pdf">ISO32000</a> document, an ISO standard describing the PDF format, with another set of formula to transform coon patches to tensor patches:</p>
<p><span class="math display">\[
\begin{matrix}
p_{11} &amp; = &amp; 1/9 \times \left(
    -4 \times p_{00} +
    6 \times (p_{01} + p_{10}) -
    2 \times (p_{03} + p_{30}) +
    3 \times (p_{31} + p_{13}) -
    1 \times p_{33} \right) \\
p_{12} &amp; = &amp; 1/9 \times \left(
    -4 \times p_{03} +
    6 \times (p_{02} + p_{13}) -
    2 \times (p_{00} + p_{33}) +
    3 \times (p_{32} + p_{10}) -
    1 \times p_{30} \right) \\
p_{21} &amp; = &amp; 1/9 \times \left(
    -4 \times p_{30} +
    6 \times (p_{31} + p_{20}) -
    2 \times (p_{33} + p_{00}) +
    3 \times (p_{01} + p_{23}) -
    1 \times p_{03} \right) \\
p_{22} &amp; = &amp; 1/9 \times \left(
    -4 \times p_{33} +
    6 \times (p_{32} + p_{23}) -
    2 \times (p_{30} + p_{03}) +
    3 \times (p_{02} + p_{20}) -
    1 \times p_{00} \right)
\end{matrix}
\]</span></p>
<p>Using these new formulas, we obtain this rendering:</p>
<div class="figure">
<img src="coon_img/good_coon_to_tensor_control.png" />

</div>
<p>We can see that the control points are further from the center and we obtain a much better smoothing of the white color accross the circle:</p>
<div class="figure">
<img src="coon_img/good_coon_to_tensor.png" />

</div>
<p>Much better :)</p>
<h2 id="bicubic-interpolation">Bicubic interpolation</h2>
<p>Let's return to our whole mesh gradient for a moment:</p>
<div class="figure">
<img src="coon_img/gradient_mesh_first.png" title="Final rendered mesh patch" />

</div>
<p>If we look at the render closely, we can see that the edges are apparent, as we use bilinear interpolation inside a patch, a neighbour patch with really different colors on the oposite vertices will create a visible discontinuity, hence the visibility of the edges.</p>
<p>To handle this problem, the SVG2 draft document propose to choose between two interpolation scheme for rendering: bilinear and bicubic (bilinear being the default one). Using the bicubic method, we obtain a much smoother rendering:</p>
<div class="figure">
<img src="coon_img/gradient_mesh_first_bicubic.png" title="Final rendered mesh patch" />

</div>
<p>We can still see the mesh edges on certain cases, but it's globally smoother. We can use the parametricity of our types to switch from a normal mesh patch to a one that will interpolate with cubic interpolation. We can first store the slope information at every vertice of the mesh:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Store the derivative necessary for cubic interpolation in</span>
<span class="co">-- the gradient mesh. We use tiny vectors because we need coefficients</span>
<span class="co">-- for every color component in the image.</span>
<span class="kw">data</span> <span class="dt">Derivative</span> px <span class="fu">=</span> <span class="dt">Derivative</span>
  { _<span class="ot">derivValues  ::</span> <span class="fu">!</span>(<span class="dt">V4</span> <span class="dt">Float</span>)
  , _<span class="ot">xDerivative  ::</span> <span class="fu">!</span>(<span class="dt">V4</span> <span class="dt">Float</span>)
  , _<span class="ot">yDerivative  ::</span> <span class="fu">!</span>(<span class="dt">V4</span> <span class="dt">Float</span>)
  , _<span class="ot">xyDerivative ::</span> <span class="fu">!</span>(<span class="dt">V4</span> <span class="dt">Float</span>)
  }

<span class="co">-- | Prepare a gradient mesh to use cubic color interpolation, see</span>
<span class="co">-- renderCubicMesh documentation to see the global use of this function.</span>
<span class="ot">calculateMeshColorDerivative ::</span> <span class="dt">MeshPatch</span> <span class="dt">PixelRGBA8</span> <span class="ot">-&gt;</span> <span class="dt">MeshPatch</span> (<span class="dt">Derivative</span> pPixelRGBA8)
calculateMeshColorDerivative mesh <span class="fu">=</span> mesh { _meshColors <span class="fu">=</span> colorDerivatives } <span class="kw">where</span>
  colorDerivatives <span class="fu">=</span>
     V.fromListN (w <span class="fu">*</span> h) [interiorDerivative x y <span class="fu">|</span> y <span class="ot">&lt;-</span> [<span class="dv">0</span> <span class="fu">..</span> h <span class="fu">-</span> <span class="dv">1</span>], x <span class="ot">&lt;-</span> [<span class="dv">0</span> <span class="fu">..</span> w <span class="fu">-</span> <span class="dv">1</span>]]

  w <span class="fu">=</span> _meshPatchWidth mesh <span class="fu">+</span> <span class="dv">1</span>
  h <span class="fu">=</span> _meshPatchHeight mesh <span class="fu">+</span> <span class="dv">1</span>
  clampX <span class="fu">=</span> max <span class="dv">0</span> <span class="fu">.</span> min (w <span class="fu">-</span> <span class="dv">1</span>)
  clampY <span class="fu">=</span> max <span class="dv">0</span> <span class="fu">.</span> min (h <span class="fu">-</span> <span class="dv">1</span>)
  toFloatPixel (<span class="dt">PixelRGBA8</span> r g b a) <span class="fu">=</span>
    <span class="dt">V4</span> (fromIntegral r) (fromIntegral g) (fromIntegral b) (fromIntegral a)    

  rawColorAt x y <span class="fu">=</span>_meshColors mesh <span class="fu">V.!</span> (y <span class="fu">*</span> w <span class="fu">+</span> x)
  atColor x y <span class="fu">=</span> toFloatPixel <span class="fu">$</span> rawColorAt (clampX x) (clampY y)
  pointAt x y <span class="fu">=</span> verticeAt mesh (clampX x) (clampY y)
  derivAt x y <span class="fu">=</span> colorDerivatives  <span class="fu">V.!</span> (y <span class="fu">*</span> w <span class="fu">+</span> x)

  interiorDerivative x y <span class="fu">=</span> <span class="dt">Derivative</span> thisColor dx dy dxy
    <span class="kw">where</span>
      dx <span class="fu">=</span> slopeBasic cxPrev cxNext xPrev xNext
      dy <span class="fu">=</span> slopeBasic cyPrev cyNext yPrev yNext

      dxy <span class="fu">|</span> nearZero xyDist <span class="fu">=</span> zero
          <span class="fu">|</span> otherwise <span class="fu">=</span> (cxyNext <span class="fu">^-^</span> cyxPrev <span class="fu">^-^</span> cyxNext <span class="fu">^+^</span> cxyPrev) <span class="fu">^/</span> (xyDist)
      xyDist <span class="fu">=</span> (xNext <span class="ot">`distance`</span> xPrev) <span class="fu">*</span> (yNext <span class="ot">`distance`</span> yPrev)

      cxyPrev <span class="fu">=</span> atColor (x <span class="fu">-</span> <span class="dv">1</span>) (y <span class="fu">-</span> <span class="dv">1</span>)
      xyPrev <span class="fu">=</span> pointAt (x <span class="fu">-</span> <span class="dv">1</span>) (y <span class="fu">-</span> <span class="dv">1</span>)

      cxyNext <span class="fu">=</span> atColor (x <span class="fu">+</span> <span class="dv">1</span>) (y <span class="fu">+</span> <span class="dv">1</span>)
      xyNext <span class="fu">=</span> pointAt (x <span class="fu">+</span> <span class="dv">1</span>) (y <span class="fu">+</span> <span class="dv">1</span>)

      cyxPrev <span class="fu">=</span> atColor (x <span class="fu">-</span> <span class="dv">1</span>) (y <span class="fu">+</span> <span class="dv">1</span>)
      yxPrev <span class="fu">=</span> pointAt (x <span class="fu">-</span> <span class="dv">1</span>) (y <span class="fu">+</span> <span class="dv">1</span>)

      cyxNext <span class="fu">=</span> atColor (x <span class="fu">+</span> <span class="dv">1</span>) (y <span class="fu">-</span> <span class="dv">1</span>)
      yxNext <span class="fu">=</span> pointAt (x <span class="fu">+</span> <span class="dv">1</span>) (y <span class="fu">-</span> <span class="dv">1</span>)

      cxPrev <span class="fu">=</span> atColor (x <span class="fu">-</span> <span class="dv">1</span>) y
      thisColor <span class="fu">=</span> atColor x y
      cxNext <span class="fu">=</span> atColor (x <span class="fu">+</span> <span class="dv">1</span>) y
      
      cyPrev <span class="fu">=</span> atColor x (y <span class="fu">-</span> <span class="dv">1</span>)
      cyNext <span class="fu">=</span> atColor x (y <span class="fu">+</span> <span class="dv">1</span>)
      
      xPrev <span class="fu">=</span> pointAt (x <span class="fu">-</span> <span class="dv">1</span>) y
      this  <span class="fu">=</span> pointAt x y
      xNext <span class="fu">=</span> pointAt (x <span class="fu">+</span> <span class="dv">1</span>) y
      
      yPrev <span class="fu">=</span> pointAt x (y <span class="fu">-</span> <span class="dv">1</span>)
      yNext <span class="fu">=</span> pointAt x (y <span class="fu">+</span> <span class="dv">1</span>)</code></pre></div>
<p>And when extracting a single patch, use the calculation used in the <a href="https://en.wikipedia.org/wiki/Bicubic_interpolation">Wikipedia</a> article to compute the final coefficients of our interpolation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Store information for cubic interpolation in a patch.</span>
<span class="kw">newtype</span> <span class="dt">CubicCoefficient</span> px <span class="fu">=</span> <span class="dt">CubicCoefficient</span>
    {<span class="ot"> getCubicCoefficients ::</span> <span class="dt">ParametricValues</span> (<span class="dt">V4</span> (<span class="dt">V4</span> <span class="dt">Float</span>))
    }

<span class="ot">rawMatrix ::</span> <span class="dt">V.Vector</span> (<span class="dt">V.Vector</span> <span class="dt">Float</span>)
rawMatrix <span class="fu">=</span> V.fromListN <span class="dv">16</span> <span class="fu">$</span> V.fromListN <span class="dv">16</span> <span class="fu">&lt;$&gt;</span>
  [ [ <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span> ]
  , [ <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span> ]
  , [<span class="fu">-</span><span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="fu">-</span><span class="dv">2</span>,<span class="fu">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span> ]
  , [ <span class="dv">2</span>,<span class="fu">-</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span> ]
  , [ <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span> ]
  , [ <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span> ]
  , [ <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="fu">-</span><span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="fu">-</span><span class="dv">2</span>,<span class="fu">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span> ]
  , [ <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">2</span>,<span class="fu">-</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span> ]
  , [<span class="fu">-</span><span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="fu">-</span><span class="dv">2</span>, <span class="dv">0</span>,<span class="fu">-</span><span class="dv">1</span>, <span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span> ]
  , [ <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="fu">-</span><span class="dv">3</span>, <span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="fu">-</span><span class="dv">2</span>, <span class="dv">0</span>,<span class="fu">-</span><span class="dv">1</span>, <span class="dv">0</span> ]
  , [ <span class="dv">9</span>,<span class="fu">-</span><span class="dv">9</span>,<span class="fu">-</span><span class="dv">9</span>, <span class="dv">9</span>,  <span class="dv">6</span>, <span class="dv">3</span>,<span class="fu">-</span><span class="dv">6</span>,<span class="fu">-</span><span class="dv">3</span>,  <span class="dv">6</span>,<span class="fu">-</span><span class="dv">6</span>, <span class="dv">3</span>,<span class="fu">-</span><span class="dv">3</span>,  <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">1</span> ]
  , [<span class="fu">-</span><span class="dv">6</span>, <span class="dv">6</span>, <span class="dv">6</span>,<span class="fu">-</span><span class="dv">6</span>, <span class="fu">-</span><span class="dv">3</span>,<span class="fu">-</span><span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">3</span>, <span class="fu">-</span><span class="dv">4</span>, <span class="dv">4</span>,<span class="fu">-</span><span class="dv">2</span>, <span class="dv">2</span>, <span class="fu">-</span><span class="dv">2</span>,<span class="fu">-</span><span class="dv">2</span>,<span class="fu">-</span><span class="dv">1</span>,<span class="fu">-</span><span class="dv">1</span> ]
  , [ <span class="dv">2</span>, <span class="dv">0</span>,<span class="fu">-</span><span class="dv">2</span>, <span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span> ]
  , [ <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">2</span>, <span class="dv">0</span>,<span class="fu">-</span><span class="dv">2</span>, <span class="dv">0</span>,  <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,  <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span> ]
  , [<span class="fu">-</span><span class="dv">6</span>, <span class="dv">6</span>, <span class="dv">6</span>,<span class="fu">-</span><span class="dv">6</span>, <span class="fu">-</span><span class="dv">4</span>,<span class="fu">-</span><span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="fu">-</span><span class="dv">3</span>, <span class="dv">3</span>,<span class="fu">-</span><span class="dv">3</span>, <span class="dv">3</span>, <span class="fu">-</span><span class="dv">2</span>,<span class="fu">-</span><span class="dv">1</span>,<span class="fu">-</span><span class="dv">2</span>,<span class="fu">-</span><span class="dv">1</span> ]
  , [ <span class="dv">4</span>,<span class="fu">-</span><span class="dv">4</span>,<span class="fu">-</span><span class="dv">4</span>, <span class="dv">4</span>,  <span class="dv">2</span>, <span class="dv">2</span>,<span class="fu">-</span><span class="dv">2</span>,<span class="fu">-</span><span class="dv">2</span>,  <span class="dv">2</span>,<span class="fu">-</span><span class="dv">2</span>, <span class="dv">2</span>,<span class="fu">-</span><span class="dv">2</span>,  <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span> ]
  ]

<span class="ot">cubicPreparator ::</span> <span class="dt">ParametricValues</span> (<span class="dt">Derivative</span> <span class="dt">PixelRGBA8</span>)
                <span class="ot">-&gt;</span> <span class="dt">CubicCoefficient</span> <span class="dt">PixelRGBA8</span>
cubicPreparator <span class="dt">ParametricValues</span> { <span class="fu">..</span> } <span class="fu">=</span>
    <span class="dt">CubicCoefficient</span> <span class="fu">$</span> <span class="dt">ParametricValues</span> (sliceAt <span class="dv">0</span>) (sliceAt <span class="dv">4</span>) (sliceAt <span class="dv">8</span>) (sliceAt <span class="dv">12</span>) <span class="kw">where</span>
  <span class="dt">Derivative</span> c00 fx00 fy00 fxy00 <span class="fu">=</span> _northValue
  <span class="dt">Derivative</span> c10 fx10 fy10 fxy10 <span class="fu">=</span> _eastValue
  <span class="dt">Derivative</span> c01 fx01 fy01 fxy01 <span class="fu">=</span> _westValue
  <span class="dt">Derivative</span> c11 fx11 fy11 fxy11 <span class="fu">=</span> _southValue

  resultVector <span class="fu">=</span> mulVec <span class="fu">$</span> V.fromListN <span class="dv">16</span>
    [  c00,   c10,   c01,   c11
    , fx00,  fx10,  fx01,  fx11 
    , fy00,  fy10,  fy01,  fy11 
    ,fxy00, fxy10, fxy01, fxy11
    ]

  mulVec vec <span class="fu">=</span> VG.foldl&#39; (<span class="fu">^+^</span>) zero <span class="fu">.</span> VG.zipWith (<span class="fu">^*</span>) vec <span class="fu">&lt;$&gt;</span> rawMatrix

  sliceAt i <span class="fu">=</span> <span class="dt">V4</span> 
    (resultVector <span class="fu">V.!</span> i)
    (resultVector <span class="fu">V.!</span> (i <span class="fu">+</span> <span class="dv">1</span>))
    (resultVector <span class="fu">V.!</span> (i <span class="fu">+</span> <span class="dv">2</span>))
    (resultVector <span class="fu">V.!</span> (i <span class="fu">+</span> <span class="dv">3</span>))</code></pre></div>
<p>Storing the cubic coefficients in a <code>V4</code> is a bit a hacky way to do it, but it let us store a 16 element vector easily. Finally to let us render the patch with the correct interpolation, we can roll a new instance of <code>BiSampleable</code>, just making a big dot product between the coefficients and our current position.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Bicubic interpolator</span>
<span class="kw">instance</span> <span class="dt">BiSampleable</span> (<span class="dt">CubicCoefficient</span> <span class="dt">PixelRGBA8</span>) <span class="dt">PixelRGBA8</span> <span class="kw">where</span>
  interpolate <span class="fu">=</span> bicubicInterpolation

<span class="ot">bicubicInterpolation ::</span> <span class="dt">CubicCoefficient</span> <span class="dt">PixelRGBA8</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">PixelRGBA8</span>
bicubicInterpolation params x y <span class="fu">=</span>
  fromFloatPixel <span class="fu">.</span> fmap clamp <span class="fu">$</span> af <span class="fu">^+^</span> bf <span class="fu">^+^</span> cf <span class="fu">^+^</span> df
  <span class="kw">where</span>
    <span class="dt">ParametricValues</span> a b c d <span class="fu">=</span> getCubicCoefficients params
    clamp <span class="fu">=</span> max <span class="dv">0</span> <span class="fu">.</span> min <span class="dv">255</span>
    <span class="co">-- we are really doing the dot product of two vector by hand, but</span>
    <span class="co">-- each element is not a scalar but a 4 element vector representing</span>
    <span class="co">-- the color</span>
    xv, vy, vyy,<span class="ot"> vyyy ::</span> <span class="dt">V4</span> <span class="dt">Float</span>
    xv <span class="fu">=</span> <span class="dt">V4</span> <span class="dv">1</span> x (x<span class="fu">*</span>x) (x<span class="fu">*</span>x<span class="fu">*</span>x)
    vy <span class="fu">=</span> xv <span class="fu">^*</span> y
    vyy <span class="fu">=</span> vy <span class="fu">^*</span> y
    vyyy <span class="fu">=</span> vyy <span class="fu">^*</span> y

    v1 <span class="fu">^^*^</span> v2 <span class="fu">=</span> (<span class="fu">^*</span>) <span class="fu">&lt;$&gt;</span> v1 <span class="fu">&lt;*&gt;</span> v2

    <span class="dt">V4</span> af bf cf df <span class="fu">=</span> (a <span class="fu">^^*^</span> xv) <span class="fu">^+^</span> (b <span class="fu">^^*^</span> vy) <span class="fu">^+^</span> (c <span class="fu">^^*^</span> vyy) <span class="fu">^+^</span> (d <span class="fu">^^*^</span> vyyy)</code></pre></div>
<h2 id="gradient-mesh-to-image-mesh">Gradient mesh to image mesh</h2>
<p>Ok, enough with interpolations, let's try something else. We're going to start with a picture:</p>
<div class="figure">
<img src="coon_img/maki_base.png" />

</div>
<p>Put a conceptual mesh grid on top of this image</p>
<div class="figure">
<img src="coon_img/maki_base_grid.png" />

</div>
<p>Shake the vertices of the mesh</p>
<div class="figure">
<img src="coon_img/maki_moved_with_grid.png" />

</div>
<p>And voilà, a wonderful distorted image:</p>
<div class="figure">
<img src="coon_img/maki_moved.png" />

</div>
<p>Any resemblance to previous techniques is purely indented. Sadly this part is not in the SVG2 draft spec.</p>
<h3 id="another-parametrization">Another parametrization</h3>
<p>Each patch interpolate within [0, 1]², so instead of interpolating between the four corner colors, we can just fetch pixels from an image. To store the information of a patch we need a new data type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Type storing the information to be able to interpolate</span>
<span class="co">-- part of an image in a patch.</span>
<span class="kw">data</span> <span class="dt">ImageMesh</span> px <span class="fu">=</span> <span class="dt">ImageMesh</span>
    { _<span class="ot">meshImage ::</span> <span class="fu">!</span>(<span class="dt">Image</span> px)
    , _<span class="ot">meshTransform ::</span> <span class="fu">!</span><span class="dt">Transformation</span>
    }</code></pre></div>
<p>The transformation is there to change space from the UV parametric space to the image space, and just fetch the pixel at the good position. I'll spare the implementation as there is not that much to do here, but it all boil down to just a new instance of <code>BiSampleable</code></p>
<p>If you forget to transform, you're in for a weird image with many patches:</p>
<div class="figure">
<img src="coon_img/maki_moved_unscaled.png" />

</div>
<h2 id="making-it-faster">Making it faster</h2>
<p>So, we have a simple implementation relying only on subdivision, and heavy subdivision is not that cheap and can result on some massive overdraw if not tuned properly (like in the code given in the sections above). And the result are not that great when interpolating an image.</p>
<p>So we can't really rely only on this algorithm for rendering. The real algorithm in use in Rasterific right now is the Fast Forward Differencing (explained in details on <a href="http://www.scratchapixel.com/lessons/advanced-rendering/bezier-curve-rendering-utah-teapot/fast-forward-differencing">scratchapixel</a>).</p>
<p>With this algorithm, you go from the parametric version of the cubic bezier curve:</p>
<p><span class="math display">\[ P(t) = P _ 0 (1 - t) ^ 3 + 3 P _ 1 t (1 - t) ^ 2 + 3 P _ 2 t^2 (1 - t) + P_3 t ^ 3 \]</span></p>
<p>to three addition between each pixel (more or less).</p>
<!--
### Deriving parametric equation from De Casteljau

With a bit of formula manipulation, we can get the correspondance between
the parametric formulation and the De Casteljau's algorithm. A quick and dirty
symbolic manipulation below using sympy:

```python
from sympy import *
from distribution import *
from sympy.matrices import *

def lerp(a, b, t):
    return (1 - t) * a + t * b

def bezier_castel(t, p0, p1, p2, p3):
    p01 = lerp(p0, p1, t)
    p12 = lerp(p1, p2, t)
    p23 = lerp(p2, p3, t)

    p0112 = lerp(p01, p12, t)
    p1223 = lerp(p12, p23, t)

    return lerp(p0112, p1223, t)

def bezier(t, p0, p1, p2, p3):
    return (     p0     *      (1 - t) ** 3 +
             3 * p1 * t *      (1 - t) ** 2 +
             3 * p2 * t ** 2 * (1 - t) +
                 p3 * t ** 3)

def casteljau_identical():
    p0, p1, p2, p3 = symbols('p0 p1 p2 p3')
    t = symbols('t')

    castel = expand(bezier_castel(t, p0, p1, p2, p3))
    raw = expand(bezier(t, p0, p1, p2, p3))

    print("De Casteljau formula")
    print("====================")
    pprint(castel, wrap_line=False)

    print("Raw parametric cubic bezier curve")
    print("=================================")
    pprint(raw, wrap_line=False)

    print("Difference, if == 0 then we can consider identical")
    print("==================================================")
    pprint(castel - raw, wrap_line=False)
```

The difference is at 0, and the expanded formula of both versions are identical.

`Qed.` (for coq user)
-->
<h3 id="forward-differentiation">Forward differentiation</h3>
<p>The core of the algorithm is to be able to go to step <span class="math inline">\(n\)</span> to step <span class="math inline">\(n+1\)</span> with small steps, doing that with only one level will only give us a straight line, as we're playing with a cubic equation, we will have to apply multiple time the forward differentiation operator.</p>
<p>The forward difference operator is defined as: <span class="math display">\[ ffd(f, t) = f(t + h) - f(t) \]</span></p>
<p>Where <span class="math inline">\(h\)</span> is the step size open to choice. We are interested to setup the coefficients for the first point of the curve (ie. for <span class="math inline">\(t = 0\)</span>), and initially, we initially want a step of 1, thus:</p>
<ul>
<li><span class="math inline">\(t = 0\)</span></li>
<li><span class="math inline">\(h = 1\)</span></li>
</ul>
<p>So using the bezier equation:</p>
<p><span class="math display">\[ P(t) = P _ 0 (1 - t) ^ 3 + 3 P _ 1 t (1 - t) ^ 2 + 3 P _ 2 t^2 (1 - t) + P_3 t ^ 3 \]</span></p>
<p>With a bit of rewriting (and the help of sympy to perform symbolic computations), we obtain:</p>
<p><span class="math display">\[
ffd_1(t) = ffd(P, t) = - h^3 p_0 + 3 h^3 p_1 - 3 h^3 p_2 + \\
    h^3 p_3 + 3 h^2 p_0 - 6 h^2 p_1 + 3 h^2 p_2 - 3 h p_0 + \\
    3 h p_1 + t^2 (- 3 h p_0 + 9 h p_1 - 9 h p_2 + 3 h p_3) + \\
    t (- 3 h^2 p_0 + 9 h^2 p_1 - 9 h^2 p_2 + 3 h^2 p_3 + \\
    6 h p_0 - 12 h p_1 + 6 h p_2)
\]</span></p>
<p>which simplify to</p>
<p><span class="math display">\[ ffd_1(0) = - p_0 + p_3 \]</span></p>
<p>in our case</p>
<p>In a similar way, we calculate second and third order differentiation:</p>
<p><span class="math display">\[
\begin{matrix}
ffd_2(t) &amp; = &amp; ffd(ffd_1, t) \\
ffd_2(0) &amp; = &amp; 6 p_1 - 12 p_2 + 6 p_3
\end{matrix}
\]</span></p>
<p>And</p>
<p><span class="math display">\[
\begin{matrix}
ffd_3(t) &amp; = &amp; ffd(ffd_2, t) \\
ffd_3(0) &amp; = &amp; - 6 p_0 + 18 p_1 - 18 p_2 + 6 p_3
\end{matrix}
\]</span></p>
<p>We can try to calculate the fourth order, but it won't yield anything:</p>
<p><span class="math display">\[
ffd_4(t) = ffd(ffd_3, t) = 0
\]</span></p>
<p>So we can stop.</p>
<p>So using this information, we set up our initial coefficients</p>
<p><span class="math display">\[
\begin{matrix}
X &amp; = &amp; x_0
A &amp; = &amp; ffd_1(0)
B &amp; = &amp; ffd_2(0)
C &amp; = &amp; ffd_3(0)
\end{matrix}
\]</span></p>
<p>And we can make an step evaluation step with a simple summation:</p>
<p><span class="math display">\[
\begin{matrix}
X&#39; = X + A
A&#39; = A + B
B&#39; = B + C
C&#39; = C
\end{matrix}
\]</span></p>
<p>Which is a far cheaper computation ### Cubic bezier rasterization using Forward difference</p>
<p>With these tools at hand, we can now write down data structure and conversion functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ForwardDifferenceCoefficient</span> <span class="fu">=</span> <span class="dt">ForwardDifferenceCoefficient</span>
    { _<span class="ot">fdA ::</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Float</span>
    , _<span class="ot">fdB ::</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Float</span>
    , _<span class="ot">fdC ::</span> <span class="ot">{-# UNPACK #-}</span> <span class="fu">!</span><span class="dt">Float</span>
    }

<span class="co">-- | Given a cubic curve, return the initial step size and</span>
<span class="co">-- the coefficient for the forward difference.</span>
<span class="co">-- Initial step is assumed to be &quot;1&quot;</span>
bezierToForwardDifferenceCoeff
<span class="ot">    ::</span> <span class="dt">CubicBezier</span>
    <span class="ot">-&gt;</span> <span class="dt">V2</span> <span class="dt">ForwardDifferenceCoefficient</span>
bezierToForwardDifferenceCoeff (<span class="dt">CubicBezier</span> x y z w) <span class="fu">=</span> <span class="dt">V2</span> xCoeffs yCoeffs
  <span class="kw">where</span>
    xCoeffs <span class="fu">=</span> <span class="dt">ForwardDifferenceCoefficient</span> { _fdA <span class="fu">=</span> ax, _fdB <span class="fu">=</span> bx, _fdC <span class="fu">=</span> cx }
    yCoeffs <span class="fu">=</span> <span class="dt">ForwardDifferenceCoefficient</span> { _fdA <span class="fu">=</span> ay, _fdB <span class="fu">=</span> by, _fdC <span class="fu">=</span> cy }

    <span class="dt">V2</span> ax ay <span class="fu">=</span> w <span class="fu">^-^</span> x <span class="co">-- ffd_1</span>
    <span class="dt">V2</span> bx by <span class="fu">=</span> (w <span class="fu">^-^</span> z <span class="fu">^*</span> <span class="dv">2</span> <span class="fu">^+^</span> y) <span class="fu">^*</span> <span class="dv">6</span> <span class="co">-- ffd_2</span>
    <span class="dt">V2</span> cx cy <span class="fu">=</span> (w <span class="fu">^-^</span> z <span class="fu">^*</span> <span class="dv">3</span> <span class="fu">^+^</span> y <span class="fu">^*</span> <span class="dv">3</span> <span class="fu">^-^</span> x) <span class="fu">^*</span> <span class="dv">6</span> <span class="co">-- ffd_3</span>

<span class="ot">halveFDCoefficients ::</span> <span class="dt">ForwardDifferenceCoefficient</span> <span class="ot">-&gt;</span> <span class="dt">ForwardDifferenceCoefficient</span>
halveFDCoefficients (<span class="dt">ForwardDifferenceCoefficient</span> a b c) <span class="fu">=</span>
    <span class="dt">ForwardDifferenceCoefficient</span> { _fdA <span class="fu">=</span> a&#39;, _fdB <span class="fu">=</span> b&#39;, _fdC <span class="fu">=</span> c&#39; }
  <span class="kw">where</span>
    c&#39; <span class="fu">=</span> c <span class="fu">*</span> <span class="fl">0.125</span>          <span class="co">-- c * 0.5 ^ 3</span>
    b&#39; <span class="fu">=</span> b <span class="fu">*</span> <span class="fl">0.25</span> <span class="fu">-</span> c&#39;      <span class="co">-- b * 0.5 ^ 2 - c * 0.5 ^ 3</span>
    a&#39; <span class="fu">=</span> (a <span class="fu">-</span> b&#39;) <span class="fu">*</span> <span class="fl">0.5</span></code></pre></div>
<p>We used <span class="math inline">\(h = 1\)</span> to simplify the calculations, which is far too big for our purpose, so we can halves the coefficients after to get almost a pixel per step (see [1])</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">updateForwardDifferencing ::</span> <span class="dt">ForwardDifferenceCoefficient</span> <span class="ot">-&gt;</span> <span class="dt">ForwardDifferenceCoefficient</span>
updateForwardDifferencing (<span class="dt">ForwardDifferenceCoefficient</span> a b c) <span class="fu">=</span>
  <span class="dt">ForwardDifferenceCoefficient</span> (a <span class="fu">+</span> b) (b <span class="fu">+</span> c) c

<span class="ot">updatePointsAndCoeff ::</span> (<span class="dt">Applicative</span> f&#39;, <span class="dt">Applicative</span> f, <span class="dt">Additive</span> f)
                     <span class="ot">=&gt;</span> f&#39; (f <span class="dt">Float</span>) <span class="ot">-&gt;</span> f&#39; (f <span class="dt">ForwardDifferenceCoefficient</span>)
                     <span class="ot">-&gt;</span> (f&#39; (f <span class="dt">Float</span>), f&#39; (f <span class="dt">ForwardDifferenceCoefficient</span>))
updatePointsAndCoeff pts coeffs <span class="fu">=</span>
    (advancePoint <span class="fu">&lt;$&gt;</span> pts <span class="fu">&lt;*&gt;</span> coeffs, fmap updateForwardDifferencing <span class="fu">&lt;$&gt;</span> coeffs)
  <span class="kw">where</span>
    fstOf (<span class="dt">ForwardDifferenceCoefficient</span> a _ _) <span class="fu">=</span> a
    advancePoint v c <span class="fu">=</span> v <span class="fu">^+^</span> (fstOf <span class="fu">&lt;$&gt;</span> c)
<span class="ot">rasterizerCubicBezier ::</span> (<span class="dt">PrimMonad</span> m, <span class="dt">ModulablePixel</span> px, <span class="dt">BiSampleable</span> src px)
                      <span class="ot">=&gt;</span> src <span class="ot">-&gt;</span> <span class="dt">CubicBezier</span> <span class="ot">-&gt;</span> <span class="dt">UV</span> <span class="ot">-&gt;</span> <span class="dt">UV</span> <span class="ot">-&gt;</span> <span class="dt">DrawContext</span> m px ()
rasterizerCubicBezier source bez uvStart uvEnd <span class="fu">=</span> <span class="kw">do</span>
  canvas <span class="ot">&lt;-</span> get
  <span class="kw">let</span> baseFfd <span class="fu">=</span> bezierToForwardDifferenceCoeff bez
      shiftCount <span class="fu">=</span> estimateFDStepCount bez
<span class="ot">      maxStepCount ::</span> <span class="dt">Int</span>
      maxStepCount <span class="fu">=</span> <span class="dv">1</span> <span class="ot">`unsafeShiftL`</span> shiftCount
      coeffStart <span class="fu">=</span> fixIter shiftCount halveFDCoefficients <span class="fu">&lt;$&gt;</span> baseFfd
      <span class="dt">V2</span> du dv <span class="fu">=</span> (uvEnd <span class="fu">^-^</span> uvStart) <span class="fu">^/</span> fromIntegral maxStepCount
      
      go <span class="fu">!</span>currentStep _ _ _ _
        <span class="fu">|</span> currentStep <span class="fu">&gt;=</span> maxStepCount <span class="fu">=</span> return ()
      go <span class="fu">!</span>currentStep <span class="fu">!</span>coeffs <span class="fu">!</span>p<span class="fu">@</span>(<span class="dt">V1</span> (<span class="dt">V2</span> x y)) <span class="fu">!</span>u <span class="fu">!</span>v <span class="fu">=</span> <span class="kw">do</span>
        <span class="kw">let</span> <span class="fu">!</span>(pNext, coeffNext) <span class="fu">=</span> updatePointsAndCoeff p coeffs
            <span class="fu">!</span>color <span class="fu">=</span> interpolate source (<span class="dt">V2</span> u v)
        plotPixel canvas color (floor x) (floor y)
        go (currentStep <span class="fu">+</span> <span class="dv">1</span>) coeffNext pNext (u <span class="fu">+</span> du) (v <span class="fu">+</span> dv)

  lift <span class="fu">$</span> go <span class="dv">0</span> (<span class="dt">V1</span> coeffStart) (<span class="dt">V1</span> <span class="fu">$</span> _cBezierX0 bez) du dv</code></pre></div>
<p>To render our tensor patch, we interpolate accross the 4 cubic bezier of the patch in one direction, and rasterize a curve made of the 4 current point at each positions, yielding the final render.</p>
<h2 id="conclusion">Conclusion</h2>
<p>So here is the end of our journey into the gradient mesh rendering for SVG2, these features will be released with the Rasterific 0.7 and the associated packages (svg-tree &amp; rasterific-svg). So let's hope browser implement quickly the support for this new feature to allow more usage of this interesting gradient object.</p>
<h2 id="bugs">Bugs</h2>
<p>Glitches are a nice, here's a collection of the nicest ones:</p>
<div class="figure">
<img src="coon_img/coon_nice_bug.png" />

</div>
<div class="figure">
<img src="coon_img/coon_bug02.png" width="400" height="400" />

</div>
<div class="figure">
<img src="coon_img/coon_bug03.png" width="400" height="400" />

</div>
<p>The grid appearing in the picture above is what happen when we don't disable anti aliasing.</p>
<div class="figure">
<img src="coon_img/compare_tensor_bad_weight.png" width="400" height="400" />

</div>
<h2 id="reference">Reference</h2>
<p>[1] Chengfu Yao, Jon Rokne An efficient algorithm for subdividing linear Coons surfaces Article in Computer Aided Geometric Design 8(4):291-303 · October 1991</p>
<p>[2] Paul S. Heckbert, Bilinear Coons Patch Image Warping Graphics Gems IV, pages{438--446}, 1994</p>
<p>[3] Lien, Shantz and Pratt &quot;Adaptive Forward Differencing for Rendering Curves and Surfaces&quot;</p>
</body>
</html>
